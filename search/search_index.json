{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tensora","text":"<p>Tensora is a tensor algebra library for Python. You can create <code>Tensor</code> objects in a variety of sparse and dense formats. You can do calculations with these tensors by passing the them to the <code>evaluate</code> function along with an expression (e.g. <code>y = evaluate('y(i) = A(i,j) * x(j)', A=A, x=x)</code>). The expression is parsed, a kernel is generated, the C code is compiled on the fly, the binary is invoked, and the result is packaged into a output <code>Tensor</code>.</p> <p>Tensora also comes with the <code>tensora</code> command line tool that can be used to generate the kernel code for external use.</p> <p>Tensora is based on the Tensor Algebra Compiler (TACO).</p>"},{"location":"#installation","title":"Installation","text":"<p>The recommended means of installation is with <code>pip</code> from PyPI.</p> <pre><code>pip install tensora\n</code></pre> <p>Tensora definitely works on Mac and Linux and definitely does not work on Windows. It will probably work on any system where <code>ffi.dlopen(None)</code> works.</p> <p>By default, Tensora uses its own code to generate the kernels. The <code>tensora[taco]</code> extra makes available the option to generate the kernels with the TACO binary, which is provided by the <code>tensora-taco</code> PyPI package.</p> <p>By default, Tensora uses LLVM to compile the kernels. The LLVM is provided by the <code>llvmlite</code> PyPI dependency and does not need to be installed on the system. The <code>tensora[cffi]</code> extra makes available the option to compile the kernels with CFFI. To do that, a C compiler must be installed on the system in a way that it is available to CFFI API mode.</p>"},{"location":"#hello-world","title":"Hello world","text":"<p>Here is an example of multiplying a sparse matrix in CSR format with a dense vector:</p> <pre><code>from tensora import Tensor, evaluate\n\nelements = {\n    (1,0): 2.0,\n    (0,1): -2.0,\n    (1,2): 4.0,\n}\n\nA = Tensor.from_dok(elements, dimensions=(2,3), format='ds')\nx = Tensor.from_lol([0, -1, 2])\n\ny = evaluate('y(i) = A(i,j) * x(j)', 'd', A=A, x=x)\n\nassert y == Tensor.from_lol([2,8])\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Tensora is free and open source software developed under an MIT license. Development occurs at the GitHub project. Contributions, big and small, are welcome.</p> <p>Bug reports and feature requests may be made directly on the issues tab.</p> <p>To make a pull request, you will need to fork the repo, clone the repo, make the changes, run the tests, push the changes, and open a PR.</p>"},{"location":"contributing/#cloning-the-repo","title":"Cloning the repo","text":"<p>To make a local copy of Tensora, clone the repository with git:</p> <pre><code>git clone https://github.com/drhagen/tensora.git\n</code></pre>"},{"location":"contributing/#installing-from-source","title":"Installing from source","text":"<p>Tensora uses uv for project and environment management with Hatchling as its build backend. In whatever environment you prefer, ensure uv is installed and then use uv to install Tensora and its dependencies:</p> <pre><code>uv sync\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Tensora uses pytest to run the tests in the <code>tests/</code> directory. The test command is encapsulated with Nox:</p> <pre><code>uv run nox -s test test_taco test_numpy\n</code></pre> <p>This will try to test with all compatible Python versions that <code>nox</code> can find. To run the tests with only a particular version, run something like this:</p> <pre><code>uv run nox -s test-3.10 test_taco-3.10 test_numpy-3.10\n</code></pre> <p>It is good to run the tests locally before making a PR, but it is not necessary to have all Python versions run. It is rare for a failure to appear in a single version, and the CI will catch it anyway.</p>"},{"location":"contributing/#code-quality","title":"Code quality","text":"<p>Tensora uses Ruff to ensure a minimum standard of code quality. The code quality commands are encapsulated with Nox:</p> <pre><code>uv run nox -s format\nuv run nox -s lint\n</code></pre>"},{"location":"contributing/#generating-the-docs","title":"Generating the docs","text":"<p>Tensora uses MkDocs to generate HTML docs from Markdown. For development purposes, they can be served locally without needing to build them first:</p> <pre><code>uv run mkdocs serve\n</code></pre> <p>To deploy the current docs to GitHub Pages, Tensora uses the MkDocs <code>gh-deploy</code> command that builds the static site on the <code>gh-pages</code> branch, commits, and pushes to the origin:</p> <pre><code>uv run mkdocs gh-deploy\n</code></pre>"},{"location":"contributing/#making-a-release","title":"Making a release","text":"<ol> <li>Bump<ol> <li>Increment version in <code>pyproject.toml</code></li> <li>Commit with message \"Bump version number to X.Y.Z\"</li> <li>Push commit to GitHub</li> <li>Check CI to ensure all tests pass</li> </ol> </li> <li>Tag<ol> <li>Tag commit with \"vX.Y.Z\"</li> <li>Push tag to GitHub</li> <li>Wait for build to finish</li> <li>Check PyPI for good upload</li> </ol> </li> <li>Document<ol> <li>Create GitHub release with name \"Tensora X.Y.Z\" and major changes in body</li> <li>If appropriate, deploy updated docs</li> </ol> </li> </ol>"},{"location":"creation/","title":"Creation","text":"<p>Creating a <code>Tensor</code> is best done via the <code>Tensor.from_*</code> methods. These methods convert a variety of data types into a <code>Tensor</code>. Most of the conversion methods optionally take both dimensions and format to determine the <code>dimensions</code> and <code>format</code> of the resulting tensor.</p>"},{"location":"creation/#tensorfrom_lol-list-of-lists","title":"<code>Tensor.from_lol</code>: list of lists","text":"<pre><code>Tensor.from_lol(\n    lol,\n    *,\n    dimensions: tuple[int, ...] = None,\n    format: Format | str = None,\n)\n</code></pre> <p>Convert a nested list of lists to a <code>Tensor</code>.</p> <ul> <li> <p><code>lol</code> is a list of lists, possibly deeply nested. That is, <code>lol</code> is a <code>float</code>, a <code>list[float]</code>, a <code>list[list[float]]</code>, etc. to an arbitrary depth of <code>list</code>s. The values are read in row-major format, meaning the top-level list is the first dimension and the deepest list (the one containing actual scalars) is the last dimension. All lists at the same level must have the same length. Note that these \"lists\" may be <code>Iterable</code>s. For those familiar, this is identical to the NumPy behavior when constructing an array from lists of lists via <code>numpy.array</code>.</p> </li> <li> <p><code>dimensions</code> has a default value that is inferred from the structure of <code>lol</code>. If provided, it must be consistent with the structure of <code>lol</code>. Providing the dimensions is typically only useful when one or more non-final dimensions may have size zero. For example, <code>Tensor.from_lol([[], []])</code> has dimensions of <code>(2,0)</code>, while <code>Tensor.from_lol([[], []], dimensions=(2,0,3))</code> has dimensions of <code>(2,0,3)</code>.</p> </li> <li> <p><code>format</code> has a default value of all dense dimensions.</p> </li> </ul> <pre><code>from tensora import Tensor\n\ntensor = Tensor.from_lol([[1,2,3], [4,5,6]])\n\nassert tensor.dimensions == (2, 3)\n</code></pre> <p>This is also the best way to create a scalar <code>Tensor</code> because passing a single number to this method means the list nesting is 0 levels deep and is therefore a 0-order tensor.</p> <pre><code>from tensora import Tensor\n\ntensor = Tensor.from_lol(2.5)\n\nassert tensor.dimensions == ()\n</code></pre>"},{"location":"creation/#tensorfrom_dok-dictionary-of-keys","title":"<code>Tensor.from_dok</code>: dictionary of keys","text":"<pre><code>Tensor.from_dok(\n    dok: dict[tuple[int, ...], float],\n    *,\n    dimensions: tuple[int, ...] = None,\n    format: Format | str = None,\n)\n</code></pre> <p>Convert a dictionary of keys to a <code>Tensor</code>.</p> <ul> <li> <p><code>dok</code> is a Python dictionary where each key is the coordinate of one nonzero value and the value of the entry is the value of the tensor at that coordinate. All coordinates not mentioned are implicitly zero.</p> </li> <li> <p><code>dimensions</code> has a default value that is the largest size in each dimension found among the coordinates.</p> </li> <li> <p><code>format</code> has a default value of dense dimensions as long as the number of nonzeros is larger than the product of those dimensions and then sparse dimensions after that. The default value is subject to change with experience.</p> </li> </ul> <pre><code>from tensora import Tensor\n\ntensor = Tensor.from_dok({\n    (1,0): 2.0,\n    (0,1): -2.0,\n    (1,2): 4.0,\n}, dimensions=(2,3), format='ds')\n\nassert tensor == Tensor.from_lol([[0,-2,0], [2,0,4]])\n</code></pre>"},{"location":"creation/#tensorfrom_aos-array-of-structs","title":"<code>Tensor.from_aos</code>: array of structs","text":"<pre><code>Tensor.from_aos(\n    aos: Iterable[tuple[int, ...]],\n    values: Iterable[float],\n    *,\n    dimensions: tuple[int, ...] = None,\n    format: Format | str = None,\n)\n</code></pre> <p>Convert a list of coordinates and a corresponding list of values to a <code>Tensor</code>.</p> <ul> <li> <p><code>aos</code> is an iterable of the coordinates of the nonzero values.</p> </li> <li> <p><code>values</code> must be the same length as <code>aos</code> and each value is the value at the corresponding coordinate.</p> </li> <li> <p><code>dimensions</code> has the same default as <code>Tensor.from_dok</code>, the largest size in each dimension.</p> </li> <li> <p><code>format</code>has the same default as <code>Tensor.from_dok</code>, dense for an many dimensions as needed to fit the nonzeros.</p> </li> </ul> <pre><code>from tensora import Tensor\n\ntensor = Tensor.from_aos(\n    [(1,0), (0,1), (1,2)],\n    [2.0, -2.0, 4.0],\n    dimensions=(2,3),\n    format='ds',\n)\n\nassert tensor == Tensor.from_lol([[0,-2,0], [2,0,4]])\n</code></pre>"},{"location":"creation/#tensorfrom_soa-struct-of-arrays","title":"<code>Tensor.from_soa</code>: struct of arrays","text":"<pre><code>Tensor.from_soa(\n    soa: tuple[Iterable[int], ...],\n    values: Iterable[float],\n    *,\n    dimensions: tuple[int, ...] = None,\n    format: Format | str = None,\n)\n</code></pre> <p>Convert lists of indexes for each dimension and a corresponding list of values to a <code>Tensor</code>.</p> <ul> <li> <p><code>soa</code> is a tuple of iterables, where each iterable is all the indexes of the corresponding dimension. All iterables must be the same length.</p> </li> <li> <p><code>values</code> must be the same length as the iterables in <code>soa</code> and each value is the nonzero value at the corresponding coordinate.</p> </li> <li> <p><code>dimensions</code> has the same default as <code>Tensor.from_dok</code>, the largest size in each dimension.</p> </li> <li> <p><code>format</code> has the same default as <code>Tensor.from_dok</code>, dense for an many dimensions as needed to fit the nonzeros.</p> </li> </ul> <pre><code>from tensora import Tensor\n\ntensor = Tensor.from_soa(\n    ([1,0,1], [0,1,2]),\n    [2.0, -2.0, 4.0],\n    dimensions=(2,3),\n    format='ds',\n)\n\nassert tensor == Tensor.from_lol([[0,-2,0], [2,0,4]])\n</code></pre>"},{"location":"creation/#tensorfrom_numpy-convert-a-numpy-array","title":"<code>Tensor.from_numpy</code>: convert a NumPy array","text":"<pre><code>Tensor.from_numpy(\n    array: numpy.ndarray,\n    *,\n    format: Format | str = None,\n)\n</code></pre> <p>Convert a NumPy array to a <code>Tensor</code>.</p> <ul> <li> <p><code>array</code> is any <code>numpy.ndarray</code>. The resulting <code>Tensor</code> will have the same order, dimensions, and values of this array.</p> </li> <li> <p><code>format</code> has a default value of all dense dimensions.</p> </li> </ul> <pre><code>import numpy as np\nfrom tensora import Tensor\n\narray = np.array([[1,2,3], [4,5,6]])\ntensor = Tensor.from_numpy(array)\n\nassert tensor == Tensor.from_lol([[1,2,3], [4,5,6]])\n</code></pre>"},{"location":"creation/#tensorfrom_scipy_sparse-convert-a-scipy-sparse-matrix","title":"<code>Tensor.from_scipy_sparse</code>: convert a SciPy sparse matrix","text":"<pre><code>Tensor.from_scipy_sparse(\n    matrix: scipy.sparse.spmatrix,\n    *,\n    format: Format | str = None,\n)\n</code></pre> <p>Convert a SciPy sparse matrix to a <code>Tensor</code>.</p> <ul> <li> <p><code>matrix</code> is any <code>scipy.sparse.spmatrix</code>. The resulting <code>Tensor</code> will have the same order, dimensions, and values of this matrix. The tensor will always have order 2.</p> </li> <li> <p><code>format</code> has a default value of <code>ds</code> for <code>csr_matrix</code> and <code>d1s0</code> for <code>csc_matrix</code> and also <code>ds</code> for the other sparse matrix types, though that is subject to changes as Tensora adds new format mode types.</p> </li> </ul> <pre><code>import scipy.sparse as sp\nfrom tensora import Tensor\n\nmatrix = sp.csr_matrix(([2.0, -2.0, 4.0], ([1,0,1], [0,1,2])), shape=(2,3))\ntensor = Tensor.from_scipy_sparse(matrix)\n\nassert tensor.format.deparse() == 'ds'\nassert tensor == Tensor.from_lol([[0,-2,0], [2,0,4]])\n</code></pre>"},{"location":"evaluate/","title":"Evaluate","text":"<pre><code>evaluate(\n    assignment: str,\n    output_format: Format | str,\n    *,\n    **inputs: Tensor,\n) -&gt; Tensor\n</code></pre> <p>The main entry point for mathematical operations in Tensora is the <code>evaluate</code> function. It takes a tensor algebra assignment and a list of <code>Tensor</code> objects. It returns a new <code>Tensor</code>, having evaluated the expression according to the input <code>Tensor</code>s.</p> <ul> <li> <p><code>assignment</code> is parsable as an algebraic tensor assignment.</p> </li> <li> <p><code>output_format</code> is the desired format of the output tensor.</p> </li> <li> <p><code>inputs</code> is all the inputs to the expression. There must be one named argument for each variable name in <code>assignment</code>. The dimensions of the tensors in <code>inputs</code> must be consistent with <code>assignment</code> and with each other.</p> </li> </ul> <p>There is also <code>evaluate_tensora</code> and <code>evaluate_taco</code> that have identical interfaces, but use different tensor algebra compilers. <code>evaluate</code> is an alias for the default, which is currently <code>evaluate_tensora</code>. <code>evaluate_taco</code> is only available if the <code>tensora[taco]</code> extra is installed.</p> <pre><code>from tensora import Tensor, evaluate\n\nA = Tensor.from_lol([[1,2,3], [4,5,6]])\nx = Tensor.from_lol([1,2,3])\n\ny = evaluate('y(i) = A(i,j) * x(j)', 'd', A=A, x=x)\nassert y == Tensor.from_lol([14, 32])\n</code></pre>"},{"location":"evaluate/#assignments","title":"Assignments","text":"<p>In a loose sense, the assignment strings use Einstein notation. The assignments are made of tensor names, index names, and operations. A tensor with its indexes is the target of the assignment on the left-hand side. Various tensors with their indexes are connected by elementary operations on the right-hand side.</p>"},{"location":"evaluate/#output-indexes","title":"Output indexes","text":"<p>Indexes that appear on both sides match an output dimension to the input dimensions sharing that index.</p> <pre><code>from tensora import Tensor, evaluate\n\na = Tensor.from_lol([1,2,3])\nb = Tensor.from_lol([4,5,6])\n\nc = evaluate('c(i) = a(i) * b(i)', 'd', a=a, b=b)\nassert c == Tensor.from_lol([4, 10, 18])\n</code></pre>"},{"location":"evaluate/#contraction-indexes","title":"Contraction indexes","text":"<p>Indexes that appear only on the right-hand side are summed over, also known as a contraction.</p> <pre><code>from tensora import Tensor, evaluate\n\nA = Tensor.from_lol([[1,2,3], [4,5,6]])\n\na = evaluate('a(i) = A(i,j)', '', A=A)\nassert a == Tensor.from_lol([6, 15])\n\nb = evaluate('b(j) = A(i,j)', '', A=A)\nassert b == Tensor.from_lol([5, 7, 9])\n</code></pre> <p>This commonly appears in the context of multiplication, in which it called an inner product.</p> <pre><code>from tensora import Tensor, evaluate\n\na = Tensor.from_lol([1,2,3])\nb = Tensor.from_lol([4,5,6])\n\nc = evaluate('c() = a(i) * b(i)', '', a=a, b=b)\nassert c == 32\n</code></pre>"},{"location":"evaluate/#broadcasting-indexes","title":"Broadcasting indexes","text":"<p>Indexes that appear only on the left-hand side would be interpreted as broadcasting the value of the right-hand side along that dimension.</p> <p>This operation is not currently allowed by <code>evaluate</code> because that indicates that the expression should be broadcast along that target dimension, but there is currently no way to specify the size of that dimension. It is allowed by the <code>tensora</code> CLI, however.</p> <pre><code>from tensora import Tensor, evaluate\n\na = Tensor.from_lol(1)\n\nb = evaluate('b(i) = a()', 'd', a=a)\n# BroadcastTargetIndexError: Expected index variable i on the target variable\n# to be mentioned on the right-hand side, but it was not: b(i) = a(). Such\n# broadcasting makes sense in a kernel and those kernels can be generated, but\n# they cannot be used in `evaluate` or `tensor_method` because those functions\n# get the output dimensions from the the dimensions of the input tensors.\n</code></pre>"},{"location":"evaluate/#reusing-tensors","title":"Reusing tensors","text":"<p>Tensor names may be repeated, possibly with different indexes. The tensor can and should only be provided once; it will be used for all occurrences of that tensor name in the assignment.</p> <pre><code>from tensora import Tensor, evaluate\n\nx = Tensor.from_lol([1,2,3])\nV = Tensor.from_lol([[1,2,3], [4,5,6], [7,8,9]])\n\ny = evaluate('y() = x(i) * V(i,j) * x(j)', '', x=x, V=V)\nassert y == 228\n</code></pre>"},{"location":"evaluate/#diagonal-indexes","title":"Diagonal indexes","text":"<p>Indexes may not be repeated within a tensor. Such syntax would represent a diagonal operation, which is currently not supported.</p> <pre><code>from tensora import Tensor, evaluate\n\nV = Tensor.from_lol([[1,2,3], [4,5,4], [3,2,1]])\n\nv = evaluate('v(i) = V(i,i)', 'd', V=V)\n# DiagonalAccessError: Diagonal access to a tensor (i.e. repeating the same\n# index within a tensor) is not currently supported: V(i, i)\n</code></pre>"},{"location":"getting-started/","title":"Getting started","text":"<p>Tensors are n-dimensional generalizations of matrices. Instead of being limited to 2 dimensions, tensors may have 3, 4, or more dimensions. They may also have 0 or 1 dimensions. The number of dimensions is the called the order. NumPy is the best known tensor library in Python; its central <code>ndarray</code> object is an example of a dense tensor.</p> <p>Each dimension of a tensor has a size. This determines, conceptually, the number of elements in the tensor. \"Conceptually\" because the number of stored elements and the amount of memory required for the tensor may be smaller than that if the tensor is sparse.</p> <p>Tensors also have a format. The format has a list of modes, which determines the internal layout of the tensor, and a mode ordering, which maps each dimension to each mode. Each mode can be either sparse or dense. An example of two different formats with the same internal layout would be CSR, which has format <code>ds</code> in Tensora, and CSC, which has format <code>d1s0</code>.</p> <p>Here are a list of common formats:</p> common name Tensora format scalar <code>''</code> dense vector <code>'d'</code> sparse vector <code>'s'</code> row-major <code>'dd'</code> column-major <code>'d1d0'</code> CSR <code>'ds'</code> CSC <code>'d1s0'</code> CSF <code>'sd'</code> DCSR <code>'ss'</code> <p>There are formats for higher order tensors, but they do not have common names. That is one of the goals of Tensora, to give access to the creation and use of new formats.</p> <p>Tensors are created via one of several static methods on the <code>Tensor</code> class. The key attributes, <code>order</code>, <code>dimensions</code>, and <code>format</code>, are available on every <code>Tensor</code>. While basic arithmetic (<code>+</code>, <code>-</code>, <code>*</code>, <code>@</code>) is available as well, it is generally better to use the <code>evaluate</code> function, which makes much more complex operations available and will fuse the loops of multiple arithmetic operators.</p>"},{"location":"tensors/","title":"Tensors","text":"<p>The main type in Tensora is the <code>Tensor</code> class. <code>Tensor</code>s are immutable. New tensors may be constructed from operations on other <code>Tensor</code>s, but no property of a <code>Tensor</code> may change once it is constructed. This is different from NumPy arrays and Scipy matrices, which may be mutated in-place.</p>"},{"location":"tensors/#attributes","title":"Attributes","text":"<p>The order, dimensions, and format are the fundamental structural properties of a tensor. These are available as attributes of a <code>Tensor</code>.</p>"},{"location":"tensors/#tensororder","title":"<code>tensor.order</code>","text":"<p>The order of a tensor is the number of dimensions it has. A scalar is a 0-order tensor, a vector is a 1-order tensor, a matrix is a 2-order tensor, and so on. Conceptually, the order may be any non-negative integer, but realistically, a large enough number of dimensions will cause a stack overflow or other resource error.</p> <pre><code>from tensora import Tensor\n\ntensor = Tensor.from_lol([[1,2,3], [4,5,6]])\nassert tensor.order == 2\n</code></pre>"},{"location":"tensors/#tensordimensions","title":"<code>tensor.dimensions</code>","text":"<p>Each element of the <code>dimensions</code> tuple is the size of the corresponding dimension.</p> <pre><code>from tensora import Tensor\n\ntensor = Tensor.from_lol([[1,2,3], [4,5,6]])\nassert tensor.dimensions == (2, 3)\n</code></pre>"},{"location":"tensors/#tensorformat","title":"<code>tensor.format</code>","text":"<p>The type of <code>format</code> is a <code>tensora.Format</code> object, which has <code>modes</code> and <code>ordering</code> attributes. The <code>format.deparse()</code> method will give you a human-readable string.</p> <pre><code>from tensora import Tensor\n\ntensor = Tensor.from_lol([[1,2,3], [4,5,6]])\nassert tensor.format.deparse() == 'dd'\n</code></pre>"},{"location":"tensors/#arithmetic","title":"Arithmetic","text":"<p>The normal way to perform mathematical operations on <code>Tensor</code>s is to use the <code>evaluate</code> function. However, the <code>Tensor</code> class implements several of the standard arithmetic operations available in Python. Tensora makes some guesses on the format of the result. If more control is needed use <code>evaluate</code>.</p>"},{"location":"tensors/#tensor1-tensor2-and-tensor1-tensor2","title":"<code>tensor1 + tensor2</code> and <code>tensor1 - tensor2</code>","text":"<p>Addition and subtraction are element-wise operations. If both operands are <code>Tensor</code>s, they must have the same order and dimensions. The result will be a <code>Tensor</code> where each dimension is dense if either operand is dense at that dimension. If one of the operands is a Python scalar, it will be broadcast to the dimensions of the other operand. The result will be a <code>Tensor</code> with the same order, dimensions, and format as the other operand.</p> <pre><code>from tensora import Tensor\n\ntensor1 = Tensor.from_lol([[1,2,3], [4,5,6]])\ntensor2 = Tensor.from_lol([[7,8,9], [10,11,12]])\n\nassert tensor1 + tensor2 == Tensor.from_lol([[8,10,12], [14,16,18]])\nassert tensor1 - tensor2 == Tensor.from_lol([[-6,-6,-6], [-6,-6,-6]])\n</code></pre>"},{"location":"tensors/#tensor1-tensor2","title":"<code>tensor1 * tensor2</code>","text":"<p>Multiplication is and element-wise operation. If both operands are <code>Tensor</code>s, they must have the same order and dimensions. The result will be a <code>Tensor</code> where each dimension is sparse if either operand is sparse at that dimension. If one of the operands is a Python scalar, it will be broadcast to the dimensions of the other operand. The result will be a <code>Tensor</code> with the same order, dimensions, and format as the other operand.</p> <pre><code>from tensora import Tensor\n\ntensor1 = Tensor.from_lol([[1,2,3], [4,5,6]])\ntensor2 = Tensor.from_lol([[7,8,9], [10,11,12]])\n\nassert tensor1 * tensor2 == Tensor.from_lol([[7,16,27], [40,55,72]])\n</code></pre>"},{"location":"tensors/#tensor1-tensor2_1","title":"<code>tensor1 @ tensor2</code>","text":"<p>Matrix multiplication is only permitted between vectors (order-1 tensors) and matrices (order-2 tensors). The dimensions of the operands must be compatible like normal and as in the table below. The result is a <code>Tensor</code> with the the expected dimensions. The format of the result is determined by the format of the operand dimensions that give the result dimension its size.</p> <code>a</code> <code>b</code> <code>a @ b</code> assignment (n,) (n,) () <code>c() = a(i) * b(i)</code> (n,) (n, p) (p,) <code>c(j) = a(i) * b(i,j)</code> (m, n) (n,) (m,) <code>c(i) = a(i,j) * b(j)</code> (m, n) (n, p) (m, p) <code>c(i,j) = a(i,k) * b(k,j)</code> <pre><code>from tensora import Tensor\n\nA = Tensor.from_lol([[1,2,3], [4,5,6]])\nx = Tensor.from_lol([1,2,3])\n\nassert A @ x == Tensor.from_lol([14, 32])\n</code></pre>"}]}